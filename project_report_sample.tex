\documentclass[a4paper]{article}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}

\author{Matthew McKague: n1234567}
\title{CAB203 Project: Eight}
\date{}

\begin{document}
\maketitle

\section{Introduction}
The classic puzzle \emph{Fifteen} consists of a square box with 15 numbered tiles in it, arranged in a $4 \times 4$ grid with one empty space.  The tiles can be slid around in the box so that a tile can be moved into the empty space.

\begin{center}
\includegraphics[width=4cm]{../../../lectures/subjects/15-puzzle.png}
\end{center}
The puzzle begins in some shuffled arrangement like that above.  The goal of the puzzle is to slide the tiles around to end up with the tiles in sequential order from left to right, top to bottom, like so:
\[\left[
   \begin{array}{cccc}
      1 & 2 & 3 & 4 \\
      5 & 6 & 7 & 8 \\
      9 & 10 & 11 & 12 \\
      13 & 14 & 15
   \end{array}
   \right]
\]

In this report we consider a variation of the Fifteen puzzle: \emph{Eight}.  Eight differs from Fifteen in that there are eight tiles rather than fifteen, arranged in a $3 \times 3$ grid.  The goal of the Eight puzzle is, given a starting arrangement of the tiles, find the shortest sequence of tile moves that results in the tiles in sequential order like so:
\[\left[
   \begin{array}{ccc}
      1 & 2 & 3 \\
      4 & 5 & 6 \\
      7 & 8
   \end{array}
   \right]
\]
or determine that there is no such sequence of moves.

\section{Problem}\label{sec:problem}
We begin by describing the puzzle rigorously.  An arrangement of tiles on the board is called a \emph{configuration} of the puzzle.  We will represent a configuration as a 9-tuple $x = (x_0, x_1, \ldots , x_8)$.  Note that indices start from 0 for consistency with the later implementation in Python.  Each $x_j$ holds the number of the tile in the position on the boarding according to this diagram:
\[\left[
   \begin{array}{ccc}
      x_0 & x_1 & x_2 \\
      x_3 & x_4 & x_5 \\
      x_6 & x_7 & x_8
   \end{array}
   \right]
\]
The empty space will be indicated with a 0.  According to this notation, the \emph{solved configuration} is given by:
\[\left[
   \begin{array}{ccc}
      1 & 2 & 3 \\
      4 & 5 & 6 \\
      7 & 8
   \end{array}
   \right]  \mapsto (1,2,3,4,5,6,7,8,0)
\]
The solved configuration will be called $x_{end}$ and the starting configuration will be $x_{start}$

While a 2-dimensional array would seem more appropriate than a linear tuple, the notation will be sufficient for our needs and will be easier to implement.

We now describe the legal tile moves.  Any tile which is adjacent to the empty space can be moved into the empty space.  This results in the empty space being moved into the location where the moved tile was previously.  Hence we can instead think of a move as the empty space itself moving, which is the approach that we will take here.  The space may move up, down, left or right, but it cannot move outside of the box.  Hence if the space is in the left column it cannot move further left.

Examining the arrangement of the $x_j$'s above, we can see that when $j = 3r + c$ (where $c = j \mod 3$ and $r = \lfloor j / 3\rfloor$) $x_j$ is in row $r$ and column $c$ where we count from 0 on the left.  Hence we can summarise which possible moves are available at any one time as follows when the 0 appears in position $j$:
\begin{itemize}
   \item The empty space can move left unless $j \mod 3 = 0$
   \item The empty space can move right unless $j \mod 3 = 2$
   \item The empty space can move up unless $\lfloor j/3 \rfloor = 0$
   \item The empty space can move left unless $\lfloor j/3 \rfloor = 2$
\end{itemize}
Recalling that $x_j = 0$, the moves can be described by:
\begin{itemize}
   \item A move left swaps $x_j$ with $x_{j - 1}$
   \item A move right swaps $x_j$ with $x_{j + 1}$
   \item A move up swaps $x_j$ with $x_{j - 3}$
   \item A move down swaps $x_j$ with $x_{j + 3}$
\end{itemize}

Now that we have described the puzzle mechanics we can discuss the problem.  Let $G = (V,E)$ be a graph with $V$ the set of configurations of the puzzle.  Two configurations $u$ and $v$ are adjacent in $G$ if there is a legal tile move that changes $u$ to $v$.  Note that if the empty space can always move back to where it came from, hence there will be another legal move (left instead of right, etc.) that takes $v$ back to $u$.  Hence $G$ is undirected.

The Eight puzzle can be summarised as follows: find a shortest path from $x_{start}$ to $x_{end}$.
\section{Solution}\label{sec:solution}
The standard method for finding shortest paths is to use a breadth first search, building a spanning tree from $x_{start}$ until we find $x_{end}$.  We will use this method.  However, we will make a modification to the method as presented in CAB203.  

For solving Eight will calculate $G$ dynamically.  There are $362880$ possible configurations of the Eight puzzle.  While this is still small enough to fit comfortably within the memory of modern computers, we will generally not need to visit all of them.  Hence to speed up the process and save memory we will only consider vertices and edges as we find them; we will not pre-compute the graph.  We will do this by taking a vertex under consideration and apply all legal moves to it to generate its neighbourhood.    

The shortest path solving method will produce a path as a sequence of vertices.  However, the Eight puzzle solution requires the sequence of moves.  While we could modify the breadth first search to remember the moves when it calculates neighbours, it is straightforward to compute the move from a pair of adjacent configurations.  Suppose that we have an edge $(u,v)$ where $u$ has $u_j = 0$ and $v$ has $v_k = 0$.  Then the move that takes $u$ to $v$ is:
\[
   M(u,v) := 
   \begin{cases} 
      \text{Left}  & : k = j - 1 \\
      \text{Right} & : k = j + 1 \\
      \text{Up}    & : k = j - 3 \\
      \text{Down}  & : k = j + 3 \\
      & \text{where} \; u_j = 0, v_k = 0
   \end{cases}
\]
These rules are found straightforwardly from the definition of the moves in the previous section.

With these preliminaries in place, we can state the solution to the Eight puzzle.  Given the starting configuration $x_{start}$ find a shortest path 
\[
   x_{start} =  v_1, v_2, \ldots, v_n = x_{end}.
\]   
   The sequence of moves is then 
\[
   M(v_1, v_2), M(v_2, v_3), \ldots, M(v_{n-1}, v_n)
\]
If there is no such path, then the breadth first search will indicate so.

\section{Implementation}
The implementation closely follows techniques from CAB203, however the spanning tree algorithm needed to be rewritten to accommodate the dynamic generation of the graph.  The function \verb+spanningTree+ is a recursive function which takes the start and end vertices and a function \verb+N+ which calculates the neighbourhood of a vertex.  After taking care of the base case, the new distance class \verb+Dnew+ is calculated from the previous distance class \verb+D+.  Here the dictionary \verb+parents+ will hold the final spanning tree, but the keys are the set of vertices which have been traversed so far.  Hence \verb+parents+ is used when calculating \verb+Dnew+ to exclude vertices which have previously been traversed.

Unlike in the CAB203 code, we add new vertices to \verb+parents+ using the \verb+update+ method which adds (key, value) pairs from a dictionary comprehension where new parents are calculated.  The method for calculating parents is a bit inefficient, calculating the neighbours of each vertex again, but it is compact and doesn't require modifications to the rest of the spanning tree algorithm.  It is also fast enough for our purposes.

\verb+shortestPath+ is modified from similar CAB203 code to detect the return value \verb+None+ from the spanning tree function, indicating that the end vertex was not found.  A few helper functions are imported from \verb+graphs.py+.

The remaining functions are specific to Eight.  Puzzle configurations are represented as tuples since we need them to be hashable to be keys in the \verb+parents+ dictionary.  \verb+swap+ is a helper function for applying moves.  It uses a list to build the resulting configuration since it is easier to take advantage of the list's mutability rather than trying to build a new tuple.  \verb+N+ checks when each type of move is possible and applies all possible moves to obtain the neighbourhood of a vertex, following the conditions described in Section~\ref{sec:problem}.  \verb+findMove+ implements $M(u,v)$ from Section~\ref{sec:solution} directly.

The main function is \verb+eightSolution+ which takes a starting configuration.  It first builds a shortest path using \verb+shortestPath+ described above.  The end vertex is the solved configuration $x_{end}$, here stored in the variable \verb+solved+.  Provided a path is found (and returning \verb+None+ otherwise) a list comprehension is used to translate the sequence of vertices to a sequence of moves corresponding to the edges in the path.  Here the construction \verb+zip(path[:-1], path[1:])+ returns the pairs of subsequent vertices in the path, i.e.\ the edges.


\end{document}